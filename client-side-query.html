<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Query statistics client-side by distance</title>

    <!-- Load the Chart.js library 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.4.0/Chart.min.js"></script>-->
    <link rel="stylesheet" href="https://js.arcgis.com/4.30/esri/themes/light/main.css" />
    <script src="https://js.arcgis.com/4.30/"></script>

    <style>
      html,
      body {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
      }

      #viewDiv {
        position: absolute;
        left: 0;
        right: 40%;
        top: 0;
        bottom: 0;
        height: 100%;
        width: 100%;
      }

      #paneDiv{
        position: absolute;
        bottom: 5%;
        width: 50%;
      }
      #slider {
        position: absolute;
        width: 100%;
      }

      #panel {
        position: absolute;
        right: 0;
        height: 100%;
        /*width: 40%;*/
        width: 0%;
        overflow: scroll;
      }
    </style>
    
    <script>
      require([
        "esri/views/MapView",
        "esri/WebMap",
        "esri/widgets/Legend",
        "esri/widgets/Expand",
        "esri/widgets/Bookmarks",
        "esri/core/lang",
        "esri/core/promiseUtils",
        "esri/core/reactiveUtils",
        "esri/layers/GraphicsLayer",
        "esri/Graphic",
        "esri/geometry/geometryEngine",
        "esri/widgets/ValuePicker",
        "esri/widgets/Slider"
      ], (MapView, WebMap, Legend, Expand, Bookmarks, lang, promiseUtils, reactiveUtils, GraphicsLayer, Graphic, geometryEngine, ValuePicker,Slider) => {
        
        // Load a web map from a portal item
        const webmap = new WebMap({
          portalItem: {
            id: "96cf806c32874026bef5f586315f098c"
            //id: "698198ea87b34c0c81b7fdba0687f6d4"
          }
        });

        // Construct two graphics layers for the buffer
        const bufferLayer = new GraphicsLayer();
        const pointLayer = new GraphicsLayer();

        // Construct the map view
        const view = new MapView({
          map: webmap,
          container: "viewDiv",
          constraints: {
            minScale: 30000000
          },
          highlightOptions: {
            color: "black",
            haloOpacity: 0.65,
            fillOpacity: 0.45
          }
        });
        
        // Add UI elements to the view

        // Displays instructions to the user for understanding the sample and places them in an Expand widget instance
        // This should be added to the top of the graph panel
/*        const titleContent = document.createElement("div");
        titleContent.style.padding = "15px";
        titleContent.style.backgroundColor = "white";
        titleContent.style.width = "350px";
        titleContent.innerHTML = [
          "<div id='title' class='esri-widget'>",
          "<span id='num-homicides'>0</span> homicides occurred within one mile of the pointer location over the last 10 years.",
          "The average age of the victims is <span id='avg-age'>0</span>. The average time an unsolved case has been",
          "open is <span id='avg-open-time'>0</span> years.",
          "</div>"
        ].join(" ");

        const titleExpand = new Expand({
          expandIcon: "dashboard",
          expandTooltip: "Summary stats",
          view: view,
          content: titleContent,
          expanded: view.widthBreakpoint !== "xsmall",
          placement: "left-start",
          group: "top-right"
        });
        view.ui.add(titleExpand, "top-right");*/
      
        // Add value picker slider
        const valuePicker = new ValuePicker({
        component: {                                                // autocasts ValuePickerSlider when type is "slider".
            type: "slider",
            min: 0,                                                   // Start value
            max: 50,                                                 // End value
            steps: [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50],      // Thumb snapping locations
            minorTicks: [5, 15, 25, 35, 45],      // Short tick lines
            majorTicks: [0, 10, 20, 30, 40, 50], // Long tick lines
            labels: [0, 10, 20, 30, 40, 50],                         // Long ticks with text
            labelFormatFunction: (value) => `${value}`               // Label definition
        },
        values: [25]                                                // "current value"
        });
        view.ui.add(valuePicker, "bottom-left"); 

/*        // Add a slider to modify the buffer size
        const slider = new Slider({
          container: "buffer-size-slider",
          min: 0,
          max: 50,
          values: [ 10 ],
          steps: [ 5, 10, 15, 20, 25, 30, 35, 40, 45, 50 ],
          snapOnClickEnabled: true,
          labelInputsEnabled: false,
          visibleElements: {
            labels: true,
            rangeLabels: true
            }                                             
        });
*/                
        //console.log("initial: ",radius)
        // Get the values as the user moves the slider
        var radius = 25; // Sets a default radius
        reactiveUtils.watch(
          () => valuePicker.values, //slider.values, 
          (values) => {
            radius = values[0]
            console.log(radius)
            }
        )      

        let highlightHandle = null;
        /**
        * Create charts and start querying the layer view when
        * the view is ready and data begins to draw in the view
        */
        view.when().then(() => {
          // Create the charts when the view is ready
          createCharts();

          const layer = webmap.layers.getItemAt(1);
          layer.outFields = ["gridcode"];
          //console.log(layer)       
          view.whenLayerView(layer).then((layerView) => {
            reactiveUtils
              .whenOnce(() => !layerView.updating)
              .then(() => {
                // Query layer view statistics as the user clicks
                // or drags the pointer across the view.
                view.on(["click", "drag"], (event) => {
                  // disables navigation by pointer drag
                  event.stopPropagation();
                  queryStatsOnDrag(layerView, event, radius)
                    .then(updateCharts)
                    .then(createBuffer(event, view, radius))
                    .catch((error) => {
                      if (error.name !== "AbortError") {
                        console.error(error);
                      }
                    });
                });
              });
          });
        });
        /**
         * Queries statistics against the layer view at the given screen location
         */
         const queryStatsOnDrag = promiseUtils.debounce((layerView, event, radius) => {
          // create a query object for the highlight and the statistics query
          const query = layerView.layer.createQuery();
          query.geometry = view.toMap(event); // converts the screen point to a map point
          query.distance = radius; // queries all features within 1 mile of the point
          query.units = "kilometers";

          const statsQuery = query.clone();
console.log(query)

          // Create the statistic definitions for querying stats from the layer view
          // the `onStatisticField` property can reference a field name or a SQL expression
          // `outStatisticFieldName` is the name of the statistic you will reference in the result
          // `statisticType` can be sum, avg, min, max, count, stddev
          const statDefinitions = [
            // total homicides
            {
              onStatisticField: "gridcode",
              outStatisticFieldName: "total",
              statisticType: "count"
            },
          ];
        })
          // add the stat definitions to the the statistics query object cloned earlier
          statsQuery.outStatistics = statDefinitions;

          // execute the query for all features in the layer view
          const allStatsResponse = layerView.queryFeatures(statsQuery).then(
            (response) => {
              console.log(response.features)
              const stats = response.features[0].attributes;
              //console.log(stats)
              return stats;
            },
            (e) => {
              console.error(e);
            }
          );
          //console.log(allStatsResponse)


          // highlight all features within the query distance
          layerView.queryObjectIds(query).then((ids) => {
            if (highlightHandle) {
              highlightHandle.remove();
              highlightHandle = null;
            }
            highlightHandle = layerView.highlight(ids);
          });

          // Return the promises that will resolve to each set of statistics
          return promiseUtils.eachAlways([allStatsResponse]); //, unsolvedStatsResponse]);
        /**
         * Updates the charts with the data returned from the statistic queries.
         */
         function updateCharts(responses) {
          console.log(responses[0].value)
            const allStats = responses[0].value;
 

          // Update the total numbers in the title UI element
          //avgAge.innerHTML = Math.round(allStats.avg_age);
          totalNumber.innerHTML = allStats.total;
          //avgOpenTime.innerHTML =
          //  unsolvedStats.avg_open_time_years != null ? unsolvedStats.avg_open_time_years.toFixed(1) : 0;
        }

        /**
         * Updates the given chart with new data
         */
        function updateChart(chart, dataValues) {
          if (chart.config.type === "doughnut") {
            chart.data.datasets[0].data = dataValues;
          } else {
            chart.data.datasets[0].data = dataValues.solved;
            chart.data.datasets[1].data = dataValues.unsolved;
          }
          chart.update();
        }

        /**
         * Creates 5 charts for summarizing homicide data
         */
        function createCharts() {
          totalNumber = document.getElementById("num-homicides");

        }                
        // Add graphic buffer
        const polySym = {
          type: "simple-fill", // autocasts as new SimpleFillSymbol()
          color: [68, 85, 90, 0.2],
          outline: {
            color: [68, 85, 90, 0.3],
            width: 2
          }
        };

        const pointSym = {
          type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
          color: [68, 85, 90],
          outline: {
            color: [255, 255, 255],
            width: 0
          },
          size: 4
        };
        // Indicates whether buffering is enabled
        let bufferEnabled = true;

        function createBuffer(event, view, radius) {
          // prevent further propagation of the current event bubbling up the event chain.
          // in this case, it will prevent default `drag` event behavior for the MapView
          // which is to move around the view by dragging the pointer.
          //event.stopPropagation();

          // convert screen coordinates to map coordinates
          const point = view.toMap(event);

          if (point) {
            bufferPoint(point,radius);
            
          }
        }

         /**
         * Buffers the given point by 560 kilometers.
         *
         * @param {esri/geometry/Point} point - A point instance to buffer.
         */
         function bufferPoint(point,radius) {
          if (!bufferEnabled) {
            console.log("buffering not enabled. Hit the b key and click/drag to buffer.");
            return;
          }

          // removes z-values from the point when taken from a SceneView.
          // GeometryEngine does not support 3D geometries.
          point.hasZ = false;
          point.z = undefined;

          if(pointLayer.graphics.length === 0){
            pointLayer.add(
              new Graphic({
                geometry: point,
                symbol: pointSym
              })
            );
          } else {
            const graphic = pointLayer.graphics.getItemAt(0);
            graphic.geometry = point;
          }

          /********************************************************************
           * Geodesic buffer calculates the true distance to buffer a point,
           * minimizing the distortion that exists when buffering points away
           * from a projection's line of tangency. This distortion is evident
           * in the 2D view of this application. This map uses a Web Mercator
           * spatial reference, which has a line of tangency at the equator.
           * Buffers created on the equator have very little distortion in their
           * shape. The further buffers are created away from the equator, the
           * more distorted they will be in their shape.
           *
           * If using a standard planar buffer, the shape of the buffers won't
           * distort in 2D views, but their size and areas will be very distorted
           * as they move away from the equator.
           ********************************************************************/
          webmap.add(bufferLayer)
          webmap.add(pointLayer)

          const buffer = geometryEngine.geodesicBuffer(point, radius, "kilometers");

          if(bufferLayer.graphics.length === 0){
            bufferLayer.add(
              new Graphic({
                geometry: buffer,
                symbol: polySym
              })
            );
          } else {
            const graphic = bufferLayer.graphics.getItemAt(0);
            graphic.geometry = buffer;
          }
        }

        });
    </script>
   </head>
  <body>
    <div id="viewDiv"></div>
    <div id="paneDiv" class="esri-widget">
<!--      <div class="title">Customize point cloud layer:</div>
      <div>Point size:</div> -->
      <div id="buffer-size-slider" class="slider"></div>
<!--      <div>Points per inch:</div>
      <div id="points-per-inch-slider" class="slider"></div>-->
    </div>

<!--     <div id="panel">
      <div style="padding: 15px">
       <canvas id="year-chart" height="250" width="550"></canvas>
        <canvas id="age-chart" height="250" width="550"></canvas>
        <canvas id="disposition-chart" width="200" height="350" style="float: left"></canvas>
        <canvas id="gender-chart" width="200" height="350" style="float: left"></canvas>
        <canvas id="race-chart" width="200" height="350" style="float: left"></canvas>
      </div>
    </div>-->
  </body>
</html>